<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,minimum-scale=1,maximum-scale=1"><link href=../../css/fonts.css rel=stylesheet type=text/css><title>Testing Hiera Data</title><link rel=stylesheet href=../../css/hugo-octopress.css><link rel=stylesheet href=../../css/fork-awesome.min.css><link href=../../favicon.png rel=icon><meta name=description content><meta name=keywords content><meta name=author content="Corey Osman"><meta name=generator content="Hugo 0.82.0"></head><body><header role=banner><hgroup><h1><a href=../../>Logical thoughts exposed</a></h1><h2>A journey through my life as a infrastructure developer</h2></hgroup></header><nav role=navigation><fieldset class=mobile-nav><select onchange="location=this.value"><option value>Navigateâ€¦</option></select></fieldset><ul class=main-navigation></ul><ul class=subscription><a href=../../index.xml target=_blank type=application/rss+xml title=RSS rel="noopener noreferrer"><i class="fa fa-rss-square fa-lg"></i></a></ul><form action=https://www.google.com/search method=get target=_blank rel="noopener noreferrer"><fieldset role=search><input class=search type=text name=q results=0 placeholder=Search>
<input type=hidden name=q value=site:/></fieldset></form></nav><div id=main><div id=content><div><article class=hentry role=article><header><p class=meta>Jan 16, 2016
- 8 minute read
- <a href=../../blog/2016-01-16-testing-hiera-data/#disqus_thread>Comments</a>
- <a class=label href=../../categories/devops/>devops </a><a class=label href=../../categories/puppet/>puppet </a><a class=label href=../../categories/testing/>testing </a><a class=label href=../../categories/hiera-validation/>hiera validation</a></p><h1 class=entry-title>Testing Hiera Data</h1></header><div class=entry-content><p>As a puppet consultant I often run into the same problems with multiple clients. Many times I can reuse a magical script and my value instantly becomes obvious. I like to think I have things figured out, but sometimes there are just problems we as a community have not solved yet.</p><p>The problem I am talking about is hiera validation. Most of us are too busy learning puppet, ruby, markdown, and git that testing is not a priority until your puppet code blows up
<a href="https://youtu.be/BkkUvMGz4A0?t=42" target=_blank rel=noopener>in your face</a>. But for those who know hiera well, and understand what bad data means, than read on.</p><pre><code>Error: Could not retrieve catalog from remote server: Error 400 on SERVER: Could not find data item lvm::volumes in any Hiera data file and no default supplied on node puppetmaster3278.nwops.io

</code></pre><h2 id=what-do-we-test>What do we test</h2><p>Traditionally, the answer to testing hiera has been to just check for correct YAML syntax. But the problem with this is that YAML is very accepting of various inputs. We need to validate hiera data not YAML.</p><h3 id=what-we-care-about>What we care about</h3><ul><li>How the hell do we test the data going into hiera?</li><li>How do we test that the keys we type, match up with the puppet parameters in the modules?</li><li>How do we test that the values in the keys are in the same format that the puppet code is expecting?</li><li>How do you test that you added all the necessary keys?</li><li>How do you test your ability to create correct YAML syntax?</li><li>How do you do all this is under 1 second?</li></ul><h2 id=how-do-we-test>How do we test</h2><p>Up until now most of use used our eyeballs to test hirea data. But my client won&rsquo;t keep me around forever and I can&rsquo;t just say look for these errors. Using <code>YAML.load_file('common.yaml')</code>
<a href=https://github.com/gds-operations/puppet-syntax/issues/39 target=_blank rel=noopener>does not do a damn thing</a>! After all we are validating hiera data not YAML.</p><p>At a previous client I used rspec-puppet and the hiera-puppet-helper to not only mock hiera but to also test real hiera data with my unit tests. But anytime someone changed the data the tests broke.</p><p>Below is an example of using rspec-puppet with hiera.</p><pre><code>require 'hiera'
hiera_file = File.expand_path(File.join(__FILE__,  '..', '..', '..', '..', 'hieradata', 'spec.yaml'))
shared_context :hiera do
  let(:hiera_config) do
    hiera_file
  end
  hiera = Hiera.new(:config =&gt; hiera_file)
end

it { is_expected.to contain_file('/tmp/test').with_content(&quot;hello&quot;)}
</code></pre><p>But none of the above solutions work reliably. And the reason behind our inability to test hiera data is we don&rsquo;t know what we are testing. We don&rsquo;t know what kind of data needs to go in those values. There is no definition or map that magically tells us what should and should not put in our hiera data. Or is there?</p><p>This is where a module schema becomes invaluable. The module schema details the exact definition of all the parameters for that module. So all we need to do is extract the schemas from every module being used into a giant master schema.</p><p>Creating a master schema might seem impossible because every single implementation of hiera data is unique. But I assure you its not impossible, just incredibly tedious. But we are devops dammit! Lets automate that shit!</p><h2 id=building-a-master-schema>Building a master schema</h2><p>I have previously explained how to
<a href=http://logicminds.github.io/blog/2016/01/15/how-to-build-a-module-schema target=_blank rel=noopener>build a module schema</a>. And I have added support for auto generating schemas with
<a href=https://github.com/nwops/puppet-retrospec target=_blank rel=noopener>retrospec puppet tool</a>. But we need to build something slightly different for validating hiera data. We need a master schema that contains all the schemas from all the modules we are using.</p><p>There are a few ways we can build up a master schema.</p><h3 id=1-use-existing-hiera-data>1. Use existing hiera data</h3><p>The hiera data you have contains all the keys and values that are currently being used. Ruby makes it easy to turn
YAML files into native ruby objects. So you can read your hiera data files and map all the keys and values into a schema pretty quickly. The only downside is your schema won&rsquo;t be very specific until you take some time to define the schema with complex data types that might be lurking in your puppet code.</p><p>I have written such a script for my client, and it works pretty awesome. My CI job fails when someone inserts hiera data without an associated mapping for it. It will even suggest the mapping to use in the master schema. Basically your just working backwards to create a schema when given data.</p><p>One additional trick is to ensure that all the hiera data keys are set to <code>required: true</code> in your schema. Because the key already exists in your hiera data it will help enforce spelling mistakes in key names.</p><h3 id=2-use-puppetfile-to-dynamically-generate-schemas-on-the-fly>2. Use Puppetfile to dynamically generate schemas on the fly</h3><p>For now this method is more of a pipe dream. But in a perfect world where every module contains a well defined schema. We could easily read the contents of the module&rsquo;s schema for each module defined in the Puppetfile and merge together the contents into a single master schema that would be unique for each permutation of the Puppetfile.</p><p>That script might look something like this:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=color:#586e75>#!/usr/bin/env ruby</span>
@master_schema <span style=color:#719e07>=</span> {}

<span style=color:#586e75># returns schema as a string</span>
<span style=color:#719e07>def</span> <span style=color:#268bd2>get_remote_schema</span>(url)
  uri <span style=color:#719e07>=</span> <span style=color:#cb4b16>URI</span><span style=color:#719e07>.</span>parse(url)
  http <span style=color:#719e07>=</span> <span style=color:#cb4b16>Net</span><span style=color:#719e07>::</span><span style=color:#cb4b16>HTTP</span><span style=color:#719e07>.</span>new(uri<span style=color:#719e07>.</span>host, uri<span style=color:#719e07>.</span>port)
  request <span style=color:#719e07>=</span> <span style=color:#cb4b16>Net</span><span style=color:#719e07>::</span><span style=color:#cb4b16>HTTP</span><span style=color:#719e07>::</span><span style=color:#cb4b16>Get</span><span style=color:#719e07>.</span>new(uri<span style=color:#719e07>.</span>request_uri)
  response <span style=color:#719e07>=</span> http<span style=color:#719e07>.</span>request(request)
  response<span style=color:#719e07>.</span>body
<span style=color:#719e07>end</span>

<span style=color:#586e75># implement the mod method that Puppetfile uses</span>
<span style=color:#719e07>def</span> <span style=color:#268bd2>mod</span>(<span style=color:#b58900>name</span>, opts<span style=color:#719e07>=</span>{})
  schema <span style=color:#719e07>=</span> <span style=color:#cb4b16>YAML</span><span style=color:#719e07>.</span>load(get_remote_schema(opts<span style=color:#719e07>[</span><span style=color:#2aa198>:url</span><span style=color:#719e07>]</span>)
  @master_schema<span style=color:#719e07>.</span>merge!(schema<span style=color:#719e07>[</span><span style=color:#2aa198>&#39;hostclass&#39;</span><span style=color:#719e07>]</span>) <span style=color:#586e75># host class parameters only</span>
<span style=color:#719e07>end</span>  

<span style=color:#b58900>eval</span>(<span style=color:#cb4b16>File</span><span style=color:#719e07>.</span>read(<span style=color:#2aa198>&#39;Puppetfile&#39;</span>) <span style=color:#586e75># read and eval the puppetfile</span>

<span style=color:#586e75># write the master schema out</span>
<span style=color:#cb4b16>File</span><span style=color:#719e07>.</span>open(<span style=color:#2aa198>&#39;master_schema.yaml&#39;</span>, <span style=color:#2aa198>&#39;w&#39;</span>) {<span style=color:#719e07>|</span>file<span style=color:#719e07>|</span> file<span style=color:#719e07>.</span>write(@master_schema<span style=color:#719e07>.</span>to_yaml)}

</code></pre></div><p>With this method we are relying solely on the developers schema to validate our hiera. Of course you could always
maintain a better more static master schema. Additionally, you could make some pull requests to update the developer&rsquo;s schema which in turn benefits everyone.</p><p>And this is where it becomes tedious. Since nobody has ever thought about creating
schemas for their puppet code it might take some time to build up your master schema.</p><p>Your schema can be as little or big as you want. The better it is the more errors that will be caught. So lets move on and assume you have a well defined master schema.</p><h2 id=building-a-script-to-validate-your-data>Building a script to validate your data</h2><p>Now that you have a master schema and lots of hiera data to validate, how do you validate all the keys across all the files? Basically you need to build a script that uses the kwalify parser to validate hiera files against your master schema. Below are some snippets from a much bigger script that does this validation.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=color:#586e75># round up all the hiera files</span>
@hiera_files <span style=color:#719e07>=</span> <span style=color:#cb4b16>Dir</span><span style=color:#719e07>.</span>glob(<span style=color:#cb4b16>File</span><span style=color:#719e07>.</span>join(<span style=color:#2aa198>&#39;data&#39;</span>,<span style=color:#2aa198>&#39;**&#39;</span>, <span style=color:#2aa198>&#34;*yaml&#34;</span>))
@hiera_files<span style=color:#719e07>.</span>each <span style=color:#719e07>do</span> <span style=color:#719e07>|</span>file<span style=color:#719e07>|</span>
  validate_file(file)
<span style=color:#719e07>end</span>

<span style=color:#586e75># an instance of the kwalify parser</span>
<span style=color:#586e75># since we don&#39;t need to create a new instance each time</span>
<span style=color:#586e75># we cache the object here</span>
<span style=color:#586e75># returns a kwalify validator parser instance</span>
<span style=color:#719e07>def</span> <span style=color:#268bd2>parser</span>
  <span style=color:#719e07>unless</span> @parser
    <span style=color:#586e75>## load schema data</span>
    schema <span style=color:#719e07>=</span> <span style=color:#cb4b16>Kwalify</span><span style=color:#719e07>::</span><span style=color:#cb4b16>Yaml</span><span style=color:#719e07>.</span>load_file(@schema_file)
    <span style=color:#586e75>## create validator</span>
    validator <span style=color:#719e07>=</span> <span style=color:#cb4b16>Kwalify</span><span style=color:#719e07>::</span><span style=color:#cb4b16>Validator</span><span style=color:#719e07>.</span>new(schema)
    @parser <span style=color:#719e07>=</span> <span style=color:#cb4b16>Kwalify</span><span style=color:#719e07>::</span><span style=color:#cb4b16>Yaml</span><span style=color:#719e07>::</span><span style=color:#cb4b16>Parser</span><span style=color:#719e07>.</span>new(validator)
  <span style=color:#719e07>end</span>
  @parser
<span style=color:#719e07>end</span>

<span style=color:#586e75># use the kwalify validator to validate each file</span>
<span style=color:#586e75># returns an array of errors if any.</span>
<span style=color:#719e07>def</span> <span style=color:#268bd2>validate_file</span>(file)
  logger<span style=color:#719e07>.</span>debug <span style=color:#2aa198>&#34;Validating file: </span><span style=color:#2aa198>#{</span>file<span style=color:#2aa198>}</span><span style=color:#2aa198>&#34;</span>
  <span style=color:#586e75>## load document and parse</span>
  document <span style=color:#719e07>=</span> parser<span style=color:#719e07>.</span>parse_file(file)
  <span style=color:#719e07>begin</span>
    errors <span style=color:#719e07>=</span> parser<span style=color:#719e07>.</span>errors <span style=color:#719e07>||</span> <span style=color:#719e07>[]</span>
  <span style=color:#719e07>rescue</span> <span style=color:#cb4b16>Kwalify</span><span style=color:#719e07>::</span><span style=color:#cb4b16>SyntaxError</span> <span style=color:#719e07>=&gt;</span> e
     <span style=color:#719e07>return</span> <span style=color:#719e07>[</span>e<span style=color:#719e07>]</span>
  <span style=color:#719e07>end</span>
<span style=color:#719e07>end</span>
</code></pre></div><p>There is actually a lot more to this script. One example is that hiera allows us to define a key in any file. But this validation doesn&rsquo;t know that because it works with one file at a time. So if a schema requires a key and that hiera data file doesn&rsquo;t contain the key, validation fails. So we have to treat all the files as one big file. We can either concat all the files together or load every file into a giant hash and use the hash to remember which keys have been validated already when they are required. Below is an example of building a giant hash.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=color:#586e75># load em up!  </span>
@referenced_keys <span style=color:#719e07>=</span> {}
@hiera_files<span style=color:#719e07>.</span>each <span style=color:#719e07>do</span> <span style=color:#719e07>|</span>file<span style=color:#719e07>|</span>
  @referenced_keys<span style=color:#719e07>.</span>merge!(<span style=color:#cb4b16>YAML</span><span style=color:#719e07>.</span>load_file(file))
<span style=color:#719e07>end</span>
</code></pre></div><p>So validation fails because it cannot find a required key but we can use some logic to determine it a thats really a problem by using our giant hash.</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby>  <span style=color:#719e07>def</span> <span style=color:#268bd2>validate_file</span>(file)
    logger<span style=color:#719e07>.</span>debug <span style=color:#2aa198>&#34;Validating file: </span><span style=color:#2aa198>#{</span>file<span style=color:#2aa198>}</span><span style=color:#2aa198>&#34;</span>
    <span style=color:#586e75>## load document and parse</span>
    document <span style=color:#719e07>=</span> parser<span style=color:#719e07>.</span>parse_file(file)
    <span style=color:#719e07>begin</span>
      errors <span style=color:#719e07>=</span> parser<span style=color:#719e07>.</span>errors <span style=color:#719e07>||</span> <span style=color:#719e07>[]</span>
    <span style=color:#719e07>rescue</span> <span style=color:#cb4b16>Kwalify</span><span style=color:#719e07>::</span><span style=color:#cb4b16>SyntaxError</span> <span style=color:#719e07>=&gt;</span> e
       <span style=color:#719e07>return</span> <span style=color:#719e07>[</span>e<span style=color:#719e07>]</span>
    <span style=color:#719e07>end</span>   
    <span style=color:#586e75># if a given key is already defined somewhere else we don&#39;t</span>
    <span style=color:#586e75># want to mark the key as required</span>
    errors<span style=color:#719e07>.</span>find_all <span style=color:#719e07>do</span> <span style=color:#719e07>|</span>error<span style=color:#719e07>|</span>
      <span style=color:#719e07>if</span> error<span style=color:#719e07>.</span>error_symbol <span style=color:#719e07>==</span> <span style=color:#2aa198>:required_nokey</span>
        <span style=color:#586e75># since this is a required no key error there is no path</span>
        <span style=color:#586e75># so we must find the key we are missing</span>
        key <span style=color:#719e07>=</span> error<span style=color:#719e07>.</span>to_s<span style=color:#719e07>.</span>match(<span style=color:#dc322f>/key\s&#39;(.*):&#39;/</span>)<span style=color:#719e07>[</span><span style=color:#2aa198>1</span><span style=color:#719e07>]</span>
        logger<span style=color:#719e07>.</span>debug <span style=color:#2aa198>&#34;Looking up key </span><span style=color:#2aa198>#{</span>key<span style=color:#2aa198>}</span><span style=color:#2aa198>&#34;</span>
        <span style=color:#719e07>!</span>@referenced_keys<span style=color:#719e07>.</span>has_key?(key) <span style=color:#586e75># if key is found this is not an error</span>
      <span style=color:#719e07>else</span>
        <span style=color:#586e75># all other errors should be returned as normal errors</span>
        <span style=color:#719e07>true</span>
      <span style=color:#719e07>end</span>
    <span style=color:#719e07>end</span>
  <span style=color:#719e07>end</span>
</code></pre></div><p>And really thats all there is to it. These are just snippets from the entire script. The other part of my script deals with creating maps given the data and also some pretty output. But hopefully it should give you an idea how to build your own validator using the kwalify parser. I would share the rest of my script but its not ready for prime time and I don&rsquo;t have the capacity to maintain another gem for public consumption. You could also go the other route by concatenating all the files together and using <code>kwalify -lf master_schema.yaml giant_hiera_data_file.yaml</code> but that might have some drawbacks.</p><h2 id=summary>Summary</h2><p>I have shown you how to
<a href=http://logicminds.github.io/blog/2016/01/15/how-to-build-a-module-schema target=_blank rel=noopener>create module schemas</a>. And this article shows you how to create a master schema in order to validate your data. So once you build up the master schema and create a validation script, the payoff is huge! Everyone wins. So go forth and give this a try.</p></div><footer><p class=meta><span class="byline author vcard">Posted by <span class=fn>Corey Osman</span></span>
<time>Jan 16, 2016</time></span></p><p class=meta><a class="basic-alignment left" href=../../blog/2016-01-15-how-to-build-a-module-schema/ title="How to build a module schema">How to build a module schema</a>
<a class="basic-alignment right" href=../../blog/2017-03-25-testing-datatypes-with-the-puppet-debugger/ title="Testing DataTypes with the Puppet Debugger">Testing DataTypes with the Puppet Debugger</a></p><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//logicalthoughtsexposed.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></footer></article></div><aside class="sidebar thirds"><section class="first odd"><p></p></section><ul class=sidebar-nav><li class=sidebar-nav-item><a target=_blank rel="noopener noreferrer" href=https://github.com/nwops/ title=https://github.com/nwops/><i class="fa fa-github fa-3x"></i></a>
<a target=_blank rel="noopener noreferrer" href=https://twitter.com/cosman2001 title=https://twitter.com/cosman2001><i class="fa fa-twitter fa-3x"></i></a>
<a target=_blank rel="noopener noreferrer" href=https://www.linkedin.com/in/logicmindscorp/ title=https://www.linkedin.com/in/logicmindscorp/><i class="fa fa-linkedin fa-3x"></i></a></li></ul><section class=odd><li><a href=../../categories/ title=Categories>Categories</a></li><li><a href=../../tags/ title=Tags>Tags</a></li></section><section class=even><h1>Recent Posts</h1><ul id=recent_posts><li class=post><a href=../../blog/2021-02-15-no-code-is-the-best-code/>No Code Is the Best Code</a></li><li class=post><a href=../../blog/2021-02-14-getting-real-with-the-ral/>Getting real with the RAL</a></li><li class=post><a href=../../blog/2019-04-02-adding-puppet-debugger-and-other-gems-when-using-pdk/>Adding Puppet Debugger and other gems when using PDK</a></li><li class=post><a href=../../blog/2018-09-25-alternative-facts/>Alternative Facts</a></li><li class=post><a href=../../blog/2018-09-25-debugging-and-inspecting-hiera-lookups/>Debugging and Inspecting hiera lookups</a></li><li class=post><a href=../../blog/2017-10-12-retrospec-the-task-generator/>Retrospec - the task generator</a></li><li class=post><a href=../../blog/2017-06-01-put-some-data-in-your-module/>Put some data in your module</a></li><li class=post><a href=../../blog/2017-04-25-break-into-your-puppet-code/>Break into your puppet code</a></li><li class=post><a href=../../blog/2017-04-24-benchmarking-your-puppet-code/>Benchmarking Your Puppet Code</a></li></ul></section></aside></div></div><footer role=contentinfo><p>Copyright &copy; 2021 Corey Osman - <a href=../../license/>License</a> -
<span class=credit>Powered by <a target=_blank href=https://gohugo.io rel="noopener noreferrer">Hugo</a> and <a target=_blank href=https://github.com/parsiya/hugo-octopress/ rel="noopener noreferrer">Hugo-Octopress</a> theme.</p></footer></body></html>